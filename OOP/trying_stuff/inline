{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "from PlottingTools import PlotSrcResSrcTrgImages\n",
    "from ipywidgets import interact, fixed\n",
    "from IPython.display import clear_output\n",
    "#%matplotlib widget\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import gui\n",
    "import registration_gui as rgui\n",
    "\n",
    "import numpy as np\n",
    "import os\n",
    "OUTPUT_DIR = 'output'\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "from PlottingTools import PlotSrcResSrcTrgImages\n",
    "from ipywidgets import interact, fixed\n",
    "from IPython.display import clear_output\n",
    "#%matplotlib widget\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "#import gui\n",
    "import registration_gui as rgui\n",
    "\n",
    "import numpy as np\n",
    "import os\n",
    "OUTPUT_DIR = 'output'\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "from PlottingTools import PlotSrcResSrcTrgImages\n",
    "from ipywidgets import interact, fixed\n",
    "from IPython.display import clear_output\n",
    "#%matplotlib widget\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "#import gui\n",
    "#import registration_gui as rgui\n",
    "\n",
    "import numpy as np\n",
    "import os\n",
    "OUTPUT_DIR = 'output'\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Callback invoked when the sitkMultiResolutionIterationEvent happens, update the index into the \n",
    "# metric_values list. \n",
    "def update_multires_iterations():\n",
    "    global metric_values, multires_iterations\n",
    "    multires_iterations.append(len(metric_values))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Callback invoked when the IterationEvent happens, update our data and display new figure.\n",
    "def plot_values(registration_method):\n",
    "    global metric_values, multires_iterations\n",
    "    \n",
    "    metric_values.append(registration_method.GetMetricValue())                                       \n",
    "    # Clear the output area (wait=True, to reduce flickering), and plot current data\n",
    "    clear_output(wait=True)\n",
    "    # Plot the similarity metric values\n",
    "    plt.plot(metric_values, 'r')\n",
    "    plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')\n",
    "    plt.xlabel('Iteration Number',fontsize=12)\n",
    "    plt.ylabel('Metric Value',fontsize=12)\n",
    "    plt.show()\n",
    "    \n",
    "# Callback invoked when the sitkMultiResolutionIterationEvent happens, update the index into the \n",
    "# metric_values list. \n",
    "def update_multires_iterations():\n",
    "    global metric_values, multires_iterations\n",
    "    multires_iterations.append(len(metric_values))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(initial_transform, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'*Took {Dtime} s to perform image registration.\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'*Took {Dtime} s to perform image registration.\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Callback invoked when the StartEvent happens, sets up our new data.\n",
    "def start_plot():\n",
    "    global metric_values, multires_iterations\n",
    "    \n",
    "    metric_values = []\n",
    "    multires_iterations = []\n",
    "\n",
    "# Callback invoked when the EndEvent happens, do cleanup of data and figure.\n",
    "def end_plot():\n",
    "    global metric_values, multires_iterations\n",
    "    \n",
    "    del metric_values\n",
    "    del multires_iterations\n",
    "    # Close figure, we don't want to get a duplicate of the plot latter on.\n",
    "    plt.close()\n",
    "\n",
    "    \n",
    "# Callback invoked when the IterationEvent happens, update our data and display new figure.\n",
    "def plot_values(registration_method):\n",
    "    global metric_values, multires_iterations\n",
    "    \n",
    "    metric_values.append(registration_method.GetMetricValue())                                       \n",
    "    # Clear the output area (wait=True, to reduce flickering), and plot current data\n",
    "    clear_output(wait=True)\n",
    "    # Plot the similarity metric values\n",
    "    plt.plot(metric_values, 'r')\n",
    "    plt.plot(multires_iterations, [metric_values[index] for index in multires_iterations], 'b*')\n",
    "    plt.xlabel('Iteration Number',fontsize=12)\n",
    "    plt.ylabel('Metric Value',fontsize=12)\n",
    "    plt.show()\n",
    "    \n",
    "# Callback invoked when the sitkMultiResolutionIterationEvent happens, update the index into the \n",
    "# metric_values list. \n",
    "def update_multires_iterations():\n",
    "    global metric_values, multires_iterations\n",
    "    multires_iterations.append(len(metric_values))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'*Took {Dtime} s to perform image registration.\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "interact(PlotSrcResSrcTrgImages,\n",
    "         SrcIm=fixed(SrcIm),\n",
    "         ResSrcIm=fixed(RegSrcIm),\n",
    "         TrgIm=fixed(TrgIm),\n",
    "         SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "         ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "         TrgInd=(0, TrgIm.GetSize()[2]-1));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "interact(PlotSrcResSrcTrgImages,\n",
    "         SrcIm=fixed(SrcIm),\n",
    "         ResSrcIm=fixed(RegSrcIm),\n",
    "         TrgIm=fixed(TrgIm),\n",
    "         SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "         ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "         TrgInd=(0, TrgIm.GetSize()[2]-1));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "interact(PlotSrcResSrcTrgImages,\n",
    "         SrcIm=fixed(SrcIm),\n",
    "         ResSrcIm=fixed(RegSrcIm),\n",
    "         TrgIm=fixed(TrgIm),\n",
    "         SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "         ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "         TrgInd=(0, TrgIm.GetSize()[2]-1));"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "from PlottingTools import PlotBlendedImage\n",
    "\n",
    "PlotBlendedImage(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotBlendedImage\n",
    "\n",
    "PlotBlendedImage(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "if False:\n",
    "    interact(PlotSrcResSrcTrgImages,\n",
    "             SrcIm=fixed(SrcIm),\n",
    "             ResSrcIm=fixed(RegSrcIm),\n",
    "             TrgIm=fixed(TrgIm),\n",
    "             SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "             ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "             TrgInd=(0, TrgIm.GetSize()[2]-1));\n",
    "\n",
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotBlendedImage\n",
    "\n",
    "PlotBlendedImage(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "if False:\n",
    "    interact(PlotSrcResSrcTrgImages,\n",
    "             SrcIm=fixed(SrcIm),\n",
    "             ResSrcIm=fixed(RegSrcIm),\n",
    "             TrgIm=fixed(TrgIm),\n",
    "             SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "             ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "             TrgInd=(0, TrgIm.GetSize()[2]-1));\n",
    "\n",
    "PlotBlendedImage(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotSrcResSrcTrgImages, PlotBlendedImage, PlotRegResults\n",
    "from ipywidgets import interact, fixed\n",
    "from IPython.display import clear_output\n",
    "#%matplotlib widget\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "#import gui\n",
    "#import registration_gui as rgui\n",
    "\n",
    "import numpy as np\n",
    "import os\n",
    "OUTPUT_DIR = 'output'\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "if False:\n",
    "    interact(PlotSrcResSrcTrgImages,\n",
    "             SrcIm=fixed(SrcIm),\n",
    "             ResSrcIm=fixed(RegSrcIm),\n",
    "             TrgIm=fixed(TrgIm),\n",
    "             SrcInd=(0, SrcIm.GetSize()[2]-1), \n",
    "             ResSrcInd=(0, RegSrcIm.GetSize()[2]-1),\n",
    "             TrgInd=(0, TrgIm.GetSize()[2]-1));\n",
    "\n",
    "#import PlottingTools\n",
    "#import importlib\n",
    "#importlib.reload(PlottingTools)\n",
    "#from PlottingTools import PlotBlendedImage\n",
    "\n",
    "#PlotBlendedImage(TrgIm, RegSrcIm, 87)\n",
    "\n",
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              #sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "#RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              #sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              #sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "#RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "#RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "#RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              #sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "ImageSamplingPercentage = 5\n",
    "\n",
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              #sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "registration_method = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(0.01)\n",
    "\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=100, \n",
    "                                        convergenceMinimumValue=1e-6, \n",
    "                                        convergenceWindowSize=10)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.            \n",
    "RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas=[2,1,0])\n",
    "RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "# Set the initial moving and optimized transforms.\n",
    "OptimisedTx = sitk.Euler3DTransform()    \n",
    "RegMethod.SetMovingInitialTransform(InitialTx)\n",
    "RegMethod.SetInitialTransform(OptimisedTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "# Need to compose the transformations after registration.\n",
    "FinalTx_v4 = RegMethod.Execute(TrgIm, SrcIm)\n",
    "#FinalTx_v4.AddTransform(InitialTx)\n",
    "\n",
    "# Always check the reason optimization terminated.\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, \n",
    "                                              SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(0.01)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# The order of parameters for the Euler3DTransform is [angle_x, angle_y, angle_z, t_x, t_y, t_z]. The parameter \n",
    "# sampling grid is centered on the initial_transform parameter values, that are all zero for the rotations. Given\n",
    "# the number of steps, their length and optimizer scales we have:\n",
    "# angle_x = 0\n",
    "# angle_y = -pi, 0, pi\n",
    "# angle_z = -pi, 0, pi\n",
    "RegMethod.SetOptimizerAsExhaustive(numberOfSteps=[0,1,1,0,0,0], stepLength = np.pi)\n",
    "RegMethod.SetOptimizerScales([1,1,1,1,1,1])\n",
    "\n",
    "#Perform the registration in-place so that the initial_transform is modified.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=True)\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "InitialTx = sitk.CenteredTransformInitializer(TrgIm, \n",
    "                                              SrcIm, \n",
    "                                              sitk.Euler3DTransform(), \n",
    "                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(0.01)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# The order of parameters for the Euler3DTransform is [angle_x, angle_y, angle_z, t_x, t_y, t_z]. The parameter \n",
    "# sampling grid is centered on the initial_transform parameter values, that are all zero for the rotations. Given\n",
    "# the number of steps, their length and optimizer scales we have:\n",
    "# angle_x = 0\n",
    "# angle_y = -pi, 0, pi\n",
    "# angle_z = -pi, 0, pi\n",
    "RegMethod.SetOptimizerAsExhaustive(numberOfSteps=[0,1,1,0,0,0], stepLength = np.pi)\n",
    "RegMethod.SetOptimizerScales([1,1,1,1,1,1])\n",
    "\n",
    "#Perform the registration in-place so that the initial_transform is modified.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=True)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "# Always check the reason optimization terminated.\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotRegResults\n",
    "\n",
    "PlotRegResults(TrgIm, RegSrcIm, 87, True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotRegResults\n",
    "\n",
    "PlotRegResults(TrgIm, RegSrcIm, 87)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "import time\n",
    "import SimpleITK as sitk\n",
    "from TestingTools import CreateDictOfPaths\n",
    "from ImageTools import ImportImage\n",
    "\n",
    "import PlottingTools\n",
    "import importlib\n",
    "importlib.reload(PlottingTools)\n",
    "from PlottingTools import PlotSrcResSrcTrgImages, PlotBlendedImage, PlotRegResults\n",
    "from ipywidgets import interact, fixed\n",
    "from IPython.display import clear_output\n",
    "#%matplotlib widget\n",
    "%matplotlib inline\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "import gui\n",
    "import registration_gui as rgui\n",
    "\n",
    "import numpy as np\n",
    "import os\n",
    "OUTPUT_DIR = 'output'\n",
    "\n",
    "PathsDict = CreateDictOfPaths()\n",
    "\n",
    "SrcDcmDir = PathsDict['Ses4_Ser11_DcmDir']\n",
    "TrgDcmDir = PathsDict['Ses10_Ser19_DcmDir']\n",
    "\n",
    "SrcIm = ImportImage(SrcDcmDir)\n",
    "TrgIm = ImportImage(TrgDcmDir)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib nbagg\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib nbagg\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib nbagg\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib nbagg\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%matplotlib nbagg\n",
    "import matplotlib\n",
    "matplotlib.use('TkAgg') \n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%matplotlib nbagg\n",
    "import matplotlib\n",
    "matplotlib.use('TkAgg')\n",
    "plt.ioff()\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib nbagg\n",
    "#import matplotlib\n",
    "#matplotlib.use('TkAgg')\n",
    "plt.ioff()\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "#%matplotlib nbagg\n",
    "#import matplotlib\n",
    "matplotlib.use('TkAgg')\n",
    "plt.ioff()\n",
    "\n",
    "#TrgWindowLevel = [1727,-320]\n",
    "#SrcWindowLevel = [355,178]\n",
    "\n",
    "PtAcqInterface = gui.RegistrationPointDataAquisition(TrgIm, SrcIm, figure_size=(8,4))#, \n",
    "                                                     #fixed_window_level=ct_window_level, \n",
    "                                                     #moving_window_level=mr_window_level);"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "fixed_image_points = [(24.062587103074605, 14.594981536981521, -58.75), \n",
    "                      (6.178716135332678, 53.93949766601378, -58.75), \n",
    "                      (74.14383149714774, -69.04462737237648, -76.25), \n",
    "                      (109.74899278747029, -14.905272533666817, -76.25)]\n",
    "\n",
    "[c for p in fixed_image_points for c in p]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "fixed_image_points = [(24.062587103074605, 14.594981536981521, -58.75), \n",
    "                      (6.178716135332678, 53.93949766601378, -58.75), \n",
    "                      (74.14383149714774, -69.04462737237648, -76.25), \n",
    "                      (109.74899278747029, -14.905272533666817, -76.25)]\n",
    "\n",
    "fixed_image_points_flat = [c for p in fixed_image_points for c in p]\n",
    "\n",
    "fixed_image_points_flat "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "SrcFudInds_flat = [c for p in SrcFudInds for c in p]\n",
    "TrgFudInds_flat = [c for p in TrgFudInds for c in p]\n",
    "\n",
    "SrcFudInds_flat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "# The indices of the fiducials (1-indexed - as from the OHIF-Viewer):\n",
    "SrcFudInds = [[246,268,176], [260,45,59], [236,432,101]]\n",
    "TrgFudInds = [[125,137,149], [150,18,72], [118,218,100]]\n",
    "\n",
    "print('\\n1-indexed indices:\\n')\n",
    "print(SrcFudInds)\n",
    "print(TrgFudInds)\n",
    "\n",
    "# The 0-indexed indices:\n",
    "SrcFudInds = [[ind - 1 for ind in inds] for inds in SrcFudInds]\n",
    "TrgFudInds = [[ind - 1 for ind in inds] for inds in TrgFudInds]\n",
    "\n",
    "print('\\n0-indexed indices:\\n')\n",
    "print(SrcFudInds)\n",
    "print(TrgFudInds)\n",
    "\n",
    "# Account for origin at bottom left rather than top left:\n",
    "SrcR, SrcC, SrcS = SrcIm.GetSize()\n",
    "TrgR, TrgC, TrgS = TrgIm.GetSize()\n",
    "\n",
    "SrcFudInds = [[inds[0], SrcR - inds[1], inds[2]] for inds in SrcFudInds]\n",
    "TrgFudInds = [[inds[0], TrgR - inds[1], inds[2]] for inds in TrgFudInds]\n",
    "\n",
    "print('')\n",
    "print(SrcFudInds)\n",
    "print(TrgFudInds)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "SrcFudInds_flat = [c for p in SrcFudInds for c in p]\n",
    "TrgFudInds_flat = [c for p in TrgFudInds for c in p]\n",
    "\n",
    "SrcFudInds_flat"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "InitialTx = sitk.LandmarkBasedTransformInitializer(sitk.VersorRigid3DTransform(), \n",
    "                                                   TrgFudInds_flat, \n",
    "                                                   SrcFudInds_flat)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\" Start timing: \"\"\"\n",
    "times = []\n",
    "times.append(time.time())\n",
    "\n",
    "#InitialTx = sitk.CenteredTransformInitializer(TrgIm, SrcIm, \n",
    "#                                              sitk.Euler3DTransform(), \n",
    "#                                              #sitk.CenteredTransformInitializerFilter.GEOMETRY)\n",
    "#                                              sitk.CenteredTransformInitializerFilter.MOMENTS)\n",
    "\n",
    "InitialTx = sitk.LandmarkBasedTransformInitializer(sitk.VersorRigid3DTransform(), \n",
    "                                                   TrgFudInds_flat, \n",
    "                                                   SrcFudInds_flat)\n",
    "\n",
    "RegMethod = sitk.ImageRegistrationMethod()\n",
    "\n",
    "# Similarity metric settings.\n",
    "RegMethod.SetMetricAsMattesMutualInformation(numberOfHistogramBins=50)\n",
    "RegMethod.SetMetricSamplingStrategy(RegMethod.RANDOM)\n",
    "RegMethod.SetMetricSamplingPercentage(float(ImageSamplingPercentage)/100)\n",
    "RegMethod.SetInterpolator(sitk.sitkLinear)\n",
    "\n",
    "# Optimizer settings.\n",
    "RegMethod.SetOptimizerAsGradientDescent(learningRate=1.0, \n",
    "                                        numberOfIterations=500, \n",
    "                                        estimateLearningRate=RegMethod.Once)\n",
    "RegMethod.SetOptimizerScalesFromPhysicalShift()\n",
    "\n",
    "# Setup for the multi-resolution framework.\n",
    "RegMethod.SetShrinkFactorsPerLevel(shrinkFactors = [4,2,1])\n",
    "RegMethod.SetSmoothingSigmasPerLevel(smoothingSigmas = [2,1,0])\n",
    "RegMethod.SmoothingSigmasAreSpecifiedInPhysicalUnitsOn()\n",
    "\n",
    "#RegMethod.SetInitialTransform(InitialTx)\n",
    "# Don't optimize in-place, we would possibly like to run this cell multiple times.\n",
    "RegMethod.SetInitialTransform(InitialTx, inPlace=False)\n",
    "\n",
    "# Connect all of the observers so that we can perform plotting during registration.\n",
    "RegMethod.AddCommand(sitk.sitkStartEvent, start_plot)\n",
    "RegMethod.AddCommand(sitk.sitkEndEvent, end_plot)\n",
    "RegMethod.AddCommand(sitk.sitkMultiResolutionIterationEvent, update_multires_iterations) \n",
    "RegMethod.AddCommand(sitk.sitkIterationEvent, lambda: plot_values(RegMethod))\n",
    "\n",
    "FinalTx = RegMethod.Execute(TrgIm, SrcIm)\n",
    "\n",
    "print('Final metric value: {0}'.format(RegMethod.GetMetricValue()))\n",
    "print('Optimizer\\'s stopping condition, {0}'.format(RegMethod.GetOptimizerStopConditionDescription()))\n",
    "#return final_transform\n",
    "\n",
    "times.append(time.time())\n",
    "Dtime = round(times[-1] - times[-2], 1)\n",
    "print(f'\\n*Took {Dtime} s to perform image registration.\\n')\n",
    "\n",
    "RegSrcIm = sitk.Resample(SrcIm, TrgIm, FinalTx, sitk.sitkLinear, 0.0, SrcIm.GetPixelID())"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
